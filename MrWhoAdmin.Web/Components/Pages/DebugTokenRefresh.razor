@page "/debug-token-refresh"
@attribute [Authorize]
@rendermode InteractiveServer
@using Microsoft.AspNetCore.Authentication
@using MrWhoAdmin.Web.Services
@using MrWho.Shared
@inject IHttpContextAccessor HttpContextAccessor
@inject ITokenRefreshService TokenRefreshService
@inject ILogger<DebugTokenRefresh> Logger
@inject NavigationManager Navigation

<PageTitle>Token Refresh Debug - MrWho Admin</PageTitle>

<RadzenText TextStyle="TextStyle.H3">Token Refresh Debug</RadzenText>

<RadzenCard class="rz-my-4">
    <RadzenStack Gap="2rem">
        <RadzenFieldset Text="Token Status">
            <RadzenStack Gap="1rem">
                <RadzenText><strong>Is Token Expired/Expiring:</strong> @isTokenExpiring</RadzenText>
                <RadzenText><strong>Access Token Available:</strong> @hasAccessToken</RadzenText>
                <RadzenText><strong>Refresh Token Available:</strong> @hasRefreshToken</RadzenText>
                @if (tokenExpiryTime.HasValue)
                {
                    <RadzenText><strong>Token Expires At:</strong> @tokenExpiryTime.Value.ToString("yyyy-MM-dd HH:mm:ss UTC")</RadzenText>
                    <RadzenText><strong>Time Until Expiry:</strong> @timeUntilExpiry</RadzenText>
                }
            </RadzenStack>
        </RadzenFieldset>

        <RadzenFieldset Text="Manual Token Operations">
            <RadzenStack Orientation="Orientation.Horizontal" Gap="1rem">
                <RadzenButton Click="@CheckTokenStatus" Text="Check Token Status" Icon="refresh" ButtonStyle="ButtonStyle.Primary" IsBusy="@isChecking" />
                <RadzenButton Click="@ForceRefreshTokenRedirect" Text="Force Refresh Token" Icon="autorenew" ButtonStyle="ButtonStyle.Success" IsBusy="@isRefreshing" />
                <RadzenButton Click="@TestApiCall" Text="Test API Call" Icon="api" ButtonStyle="ButtonStyle.Secondary" IsBusy="@isTestingApi" />
            </RadzenStack>
        </RadzenFieldset>

        <RadzenFieldset Text="Operation Results">
            @if (!string.IsNullOrEmpty(lastOperationResult))
            {
                <RadzenAlert AlertStyle="@(lastOperationSuccess ? AlertStyle.Success : AlertStyle.Danger)" class="rz-mt-3">
                    <RadzenText>@lastOperationResult</RadzenText>
                </RadzenAlert>
            }
            
            @if (showRefreshError)
            {
                <RadzenAlert AlertStyle="AlertStyle.Warning" class="rz-mt-3">
                    <RadzenText>Token refresh completed, but there may have been an issue. Check the token status above.</RadzenText>
                </RadzenAlert>
            }
        </RadzenFieldset>

        <RadzenFieldset Text="Token Refresh Methods">
            <RadzenStack Gap="1rem">
                <RadzenText><strong>1. Redirect Method (Recommended):</strong> Uses standard HTTP context outside Blazor - most reliable</RadzenText>
                <RadzenText><strong>2. Blazor Method:</strong> Attempts refresh within Blazor context - may have limitations</RadzenText>
                <RadzenText><strong>3. Automatic:</strong> Middleware and delegating handler refresh automatically</RadzenText>
            </RadzenStack>
        </RadzenFieldset>

        <RadzenFieldset Text="How Token Refresh Works">
            <RadzenStack Gap="1rem">
                <RadzenText><strong>1. Automatic Refresh:</strong> Middleware checks token expiry on interactive requests and refreshes if needed</RadzenText>
                <RadzenText><strong>2. API Call Refresh:</strong> Delegating handler ensures valid tokens before API calls</RadzenText>
                <RadzenText><strong>3. Manual Refresh:</strong> Uses redirect to MVC controller for reliable token updates</RadzenText>
                <RadzenText><strong>4. Fallback:</strong> If refresh fails, user will need to log in again</RadzenText>
            </RadzenStack>
        </RadzenFieldset>

        <RadzenFieldset Text="Token Refresh Configuration">
            <RadzenStack Gap="1rem">
                <RadzenText><strong>Refresh Before Expiry:</strong> 5 minutes</RadzenText>
                <RadzenText><strong>Automatic Refresh:</strong> Enabled via middleware</RadzenText>
                <RadzenText><strong>API Call Auto-Refresh:</strong> Enabled via delegating handler</RadzenText>
                <RadzenText><strong>Manual Refresh:</strong> Uses redirect-based approach for reliable token updates</RadzenText>
            </RadzenStack>
        </RadzenFieldset>
    </RadzenStack>
</RadzenCard>

@code {
    private bool isTokenExpiring = false;
    private bool hasAccessToken = false;
    private bool hasRefreshToken = false;
    private DateTimeOffset? tokenExpiryTime = null;
    private string timeUntilExpiry = "";
    
    private bool isChecking = false;
    private bool isRefreshing = false;
    private bool isTestingApi = false;
    
    private string lastOperationResult = "";
    private bool lastOperationSuccess = false;
    private bool showRefreshError = false;

    protected override async Task OnInitializedAsync()
    {
        await CheckTokenStatus();
        
        // Check if we returned from a redirect with an error
        var uri = new Uri(Navigation.Uri);
        var query = System.Web.HttpUtility.ParseQueryString(uri.Query);
        showRefreshError = query["refreshError"] == "true";
    }

    private async Task CheckTokenStatus()
    {
        isChecking = true;
        lastOperationResult = "";
        
        try
        {
            var httpContext = HttpContextAccessor.HttpContext;
            if (httpContext != null)
            {
                // Check if token is expiring
                isTokenExpiring = await TokenRefreshService.IsTokenExpiredOrExpiringSoonAsync(httpContext);
                
                // Check for tokens
                var accessToken = await httpContext.GetTokenAsync(TokenConstants.TokenNames.AccessToken);
                hasAccessToken = !string.IsNullOrEmpty(accessToken);
                
                var refreshToken = await httpContext.GetTokenAsync(TokenConstants.TokenNames.RefreshToken);
                hasRefreshToken = !string.IsNullOrEmpty(refreshToken);
                
                // Try to get token expiry
                var expiresAtString = await httpContext.GetTokenAsync(TokenConstants.TokenNames.ExpiresAt);
                if (!string.IsNullOrEmpty(expiresAtString) && DateTimeOffset.TryParse(expiresAtString, out var expiresAt))
                {
                    tokenExpiryTime = expiresAt;
                    var timeLeft = expiresAt - DateTimeOffset.UtcNow;
                    timeUntilExpiry = $"{timeLeft.Days}d {timeLeft.Hours}h {timeLeft.Minutes}m {timeLeft.Seconds}s";
                }
                else
                {
                    tokenExpiryTime = null;
                    timeUntilExpiry = "Unknown";
                }
                
                lastOperationResult = "Token status checked successfully";
                lastOperationSuccess = true;
            }
        }
        catch (Exception ex)
        {
            lastOperationResult = $"Error checking token status: {ex.Message}";
            lastOperationSuccess = false;
            Logger.LogError(ex, "Error checking token status");
        }
        finally
        {
            isChecking = false;
            StateHasChanged();
        }
    }

    private async Task ForceRefreshTokenRedirect()
    {
        isRefreshing = true;
        
        try
        {
            // Build the return URL for after refresh
            var currentUrl = Navigation.Uri;
            var refreshUrl = $"/token/refresh?returnUrl={Uri.EscapeDataString(currentUrl)}";
            
            // Use NavigationManager for safer navigation
            Navigation.NavigateTo(refreshUrl, forceLoad: true);
        }
        catch (Exception ex)
        {
            lastOperationResult = $"Error initiating token refresh redirect: {ex.Message}";
            lastOperationSuccess = false;
            Logger.LogError(ex, "Error initiating token refresh redirect");
            isRefreshing = false;
            StateHasChanged();
        }
    }

    private async Task TestApiCall()
    {
        isTestingApi = true;
        lastOperationResult = "";
        
        try
        {
            var httpContext = HttpContextAccessor.HttpContext;
            if (httpContext != null)
            {
                var accessToken = await httpContext.GetTokenAsync(TokenConstants.TokenNames.AccessToken);
                
                if (string.IsNullOrEmpty(accessToken))
                {
                    lastOperationResult = "No access token available for API call";
                    lastOperationSuccess = false;
                }
                else
                {
                    using var httpClient = new HttpClient();
                    httpClient.BaseAddress = new Uri("https://localhost:7113/");
                    httpClient.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue(TokenConstants.TokenTypes.Bearer, accessToken);
                    
                    var response = await httpClient.GetAsync("api/realms?page=1&pageSize=1");
                    
                    if (response.IsSuccessStatusCode)
                    {
                        var content = await response.Content.ReadAsStringAsync();
                        lastOperationResult = $"API call successful! Response length: {content.Length} characters";
                        lastOperationSuccess = true;
                    }
                    else
                    {
                        var errorContent = await response.Content.ReadAsStringAsync();
                        lastOperationResult = $"API call failed: {response.StatusCode} - {errorContent}";
                        lastOperationSuccess = false;
                    }
                }
            }
        }
        catch (Exception ex)
        {
            lastOperationResult = $"Exception during API test: {ex.Message}";
            lastOperationSuccess = false;
            Logger.LogError(ex, "Error testing API call");
        }
        finally
        {
            isTestingApi = false;
            StateHasChanged();
        }
    }
}}}