@page "/debug/auth-diagnostics"
@rendermode InteractiveServer
@inject ILogger<AuthDiagnostics> Logger
@inject IConfiguration Configuration
@inject NavigationManager Navigation
@inject ITokenRefreshService TokenRefreshService
@inject IJSRuntime JSRuntime
@using Microsoft.AspNetCore.Components.Authorization
@implements IDisposable

<PageTitle>Authentication Diagnostics</PageTitle>

<div class="container mt-4">
    <h2>?? Authentication Diagnostics</h2>
    <p class="text-muted">This page helps diagnose infinite login loop issues</p>

    <div class="row">
        <div class="col-md-6">
            <div class="card">
                <div class="card-header">
                    <h5>Configuration Check</h5>
                </div>
                <div class="card-body">
                    <div class="mb-3">
                        <strong>Authority:</strong> <code>@Authority</code>
                        <div class="@GetStatusClass(AuthorityStatus)">@AuthorityStatusMessage</div>
                    </div>
                    
                    <div class="mb-3">
                        <strong>Client ID:</strong> <code>@ClientId</code>
                    </div>
                    
                    <div class="mb-3">
                        <strong>Current URL:</strong> <code>@CurrentUrl</code>
                    </div>
                    
                    <div class="mb-3">
                        <strong>Expected Callback:</strong> <code>@ExpectedCallback</code>
                    </div>
                </div>
            </div>
        </div>

        <div class="col-md-6">
            <div class="card">
                <div class="card-header">
                    <h5>Authentication State</h5>
                </div>
                <div class="card-body">
                    @if (_hasRendered)
                    {
                        <CascadingAuthenticationState>
                            <AuthorizeView>
                                <Authorized>
                                    <div class="alert alert-success">
                                        ? User is authenticated as: <strong>@context.User.Identity?.Name</strong>
                                    </div>
                                    
                                    <div class="mb-2">
                                        <strong>Claims Count:</strong> @context.User.Claims.Count()
                                    </div>
                                    
                                    <div class="mb-2">
                                        <strong>Auth Type:</strong> @context.User.Identity?.AuthenticationType
                                    </div>
                                    
                                    <button @onclick="CheckTokenStatus" class="btn btn-info btn-sm">
                                        Check Token Status
                                    </button>
                                </Authorized>
                                <NotAuthorized>
                                    <div class="alert alert-warning">
                                        ? User is not authenticated
                                    </div>
                                </NotAuthorized>
                            </AuthorizeView>
                        </CascadingAuthenticationState>
                    }
                    else
                    {
                        <div class="alert alert-info">
                            <div class="spinner-border spinner-border-sm me-2" role="status"></div>
                            Checking authentication state...
                        </div>
                    }
                </div>
            </div>
        </div>
    </div>

    <div class="row mt-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <h5>Quick Actions</h5>
                </div>
                <div class="card-body">
                    <div class="btn-group" role="group">
                        <button @onclick="TestOidcDiscovery" class="btn btn-primary" disabled="@(!_hasRendered)">
                            Test OIDC Discovery
                        </button>
                        <button @onclick="TestClientConfig" class="btn btn-primary" disabled="@(!_hasRendered)">
                            Test Client Config
                        </button>
                        <button @onclick="ClearAuthState" class="btn btn-warning" disabled="@(!_hasRendered)">
                            Clear Auth State
                        </button>
                        <button @onclick="TestLogin" class="btn btn-success" disabled="@(!_hasRendered)">
                            Test Login Flow
                        </button>
                        <button @onclick="StartParViaChallenge" class="btn btn-outline-success" disabled="@(!_hasRendered)" title="Use OIDC Challenge with PAR">
                            PAR Login Test
                        </button>
                        <button @onclick="@(async ()=> await ParLoginWithLocalCallback())" class="btn btn-outline-secondary" disabled="@(!_hasRendered)" title="PAR using local /callback page (no middleware)">
                            PAR Test (Local Callback)
                        </button>
                        <button @onclick="StartParViaChallenge" class="btn btn-outline-primary" disabled="@(!_hasRendered)" title="Use OIDC Challenge with PAR">
                            PAR + Challenge
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    @if (!string.IsNullOrEmpty(DiagnosticsResult))
    {
        <div class="row mt-4">
            <div class="col-12">
                <div class="card">
                    <div class="card-header">
                        <h5>Diagnostics Results</h5>
                    </div>
                    <div class="card-body">
                        <pre class="bg-light p-3" style="max-height: 400px; overflow-y: auto;">@DiagnosticsResult</pre>
                    </div>
                </div>
            </div>
        </div>
    }

    <div class="row mt-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <h5>Expected Authentication Flow</h5>
                </div>
                <div class="card-body">
                    <ol>
                        <li>User accesses protected page ? <code>/realms</code></li>
                        <li>Redirect to login ? <code>/login?returnUrl=/realms</code></li>
                        <li>OIDC challenge ? <code>https://localhost:7113/connect/authorize?...</code></li>
                        <li>User authenticates at OIDC server</li>
                        <li>Callback with code ? <code>/signin-oidc</code></li>
                        <li>Token exchange and redirect ? <code>/realms</code></li>
                    </ol>
                    
                    <div class="alert alert-info mt-3">
                        <strong>If you see infinite loops:</strong> The flow stops at step 5 or 6 and redirects back to step 2.
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

@code {
    private string Authority = "";
    private string ClientId = "";
    private string CurrentUrl = "";
    private string ExpectedCallback = "";
    private string AuthorityStatusMessage = "Checking...";
    private string AuthorityStatus = "unknown";
    private string DiagnosticsResult = "";
    private bool _hasRendered = false;
    private bool _disposed = false;

    protected override Task OnInitializedAsync()
    {
        if (_disposed) return Task.CompletedTask;
        
        try
        {
            var authConfig = Configuration.GetSection("Authentication");
            var rawAuthority = authConfig.GetValue<string>("Authority") ?? "https://localhost:7113"; // allow missing trailing slash
            Authority = NormalizeBaseUrl(rawAuthority);
            ClientId = authConfig.GetValue<string>("ClientId") ?? "mrwho_admin_web";
            CurrentUrl = Navigation.Uri;
            ExpectedCallback = Navigation.BaseUri + "signin-oidc";
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error during initialization");
        }
        
    return Task.CompletedTask;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_disposed) return;
        
        if (firstRender)
        {
            _hasRendered = true;
            await CheckAuthorityStatus();
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    private async Task CheckAuthorityStatus()
    {
        if (_disposed) return;
        
        try
        {
            using var httpClient = new HttpClient();
            httpClient.Timeout = TimeSpan.FromSeconds(5);

            var discoveryUrl = Combine(Authority, "/.well-known/openid-configuration");
            var response = await httpClient.GetAsync(discoveryUrl);
            if (response.IsSuccessStatusCode)
            {
                AuthorityStatus = "success";
                AuthorityStatusMessage = "? OIDC discovery endpoint is accessible";
            }
            else
            {
                AuthorityStatus = "error";
                AuthorityStatusMessage = $"? OIDC discovery returned: {response.StatusCode}";
            }
        }
        catch (Exception ex)
        {
            AuthorityStatus = "error";
            AuthorityStatusMessage = $"? Cannot reach OIDC server: {ex.Message}";
        }

        if (!_disposed)
        {
            StateHasChanged();
        }
    }

    private Task CheckTokenStatus()
    {
        if (_disposed || !_hasRendered) return Task.CompletedTask;

        DiagnosticsResult = "Checking token status...\n";
        StateHasChanged();

        try
        {
            DiagnosticsResult += "Token status check is only available server-side.\n";
            DiagnosticsResult += "Use /auth/status endpoint for detailed token information.\n";
        }
        catch (Exception ex)
        {
            DiagnosticsResult += $"Error checking token: {ex.Message}\n";
        }

        if (!_disposed)
        {
            StateHasChanged();
        }

        return Task.CompletedTask;
    }

    private async Task TestOidcDiscovery()
    {
        if (_disposed || !_hasRendered) return;

        DiagnosticsResult = "Testing OIDC Discovery...\n";
        StateHasChanged();

        try
        {
            using var httpClient = new HttpClient();
            var discoveryUrl = Combine(Authority, "/.well-known/openid-configuration");
            var response = await httpClient.GetAsync(discoveryUrl);
            var content = await response.Content.ReadAsStringAsync();
            
            DiagnosticsResult += $"Status: {response.StatusCode}\n";
            if (response.IsSuccessStatusCode)
            {
                var discovery = System.Text.Json.JsonSerializer.Deserialize<System.Text.Json.JsonElement>(content);
                
                DiagnosticsResult += $"Authorization Endpoint: {discovery.GetProperty("authorization_endpoint").GetString()}\n";
                DiagnosticsResult += $"Token Endpoint: {discovery.GetProperty("token_endpoint").GetString()}\n";
                DiagnosticsResult += $"End Session Endpoint: {discovery.GetProperty("end_session_endpoint").GetString()}\n";
            }
            else
            {
                DiagnosticsResult += $"Error: {content}\n";
            }
        }
        catch (Exception ex)
        {
            DiagnosticsResult += $"Exception: {ex.Message}\n";
        }
        
        if (!_disposed)
        {
            StateHasChanged();
        }
    }

    private async Task TestClientConfig()
    {
        if (_disposed || !_hasRendered) return;

        DiagnosticsResult = "Testing Client Configuration...\n";
        StateHasChanged();

        try
        {
            using var httpClient = new HttpClient();
            var clientInfoUrl = Combine(Authority, "/debug/admin-client-info");
            var response = await httpClient.GetAsync(clientInfoUrl);
            var content = await response.Content.ReadAsStringAsync();
            
            DiagnosticsResult += $"Status: {response.StatusCode}\n";
            if (response.IsSuccessStatusCode)
            {
                var clientInfo = System.Text.Json.JsonSerializer.Deserialize<System.Text.Json.JsonElement>(content);
                
                DiagnosticsResult += $"Client ID: {clientInfo.GetProperty("ClientId").GetString()}\n";
                DiagnosticsResult += $"Client Name: {clientInfo.GetProperty("Name").GetString()}\n";
                DiagnosticsResult += $"Is Enabled: {clientInfo.GetProperty("IsEnabled").GetBoolean()}\n";
                
                var redirectUris = clientInfo.GetProperty("RedirectUris").EnumerateArray()
                    .Select(x => x.GetString()).ToList();
                DiagnosticsResult += $"Redirect URIs: {string.Join(", ", redirectUris)}\n";
                
                var expectedUri = Navigation.BaseUri.TrimEnd('/') + "/signin-oidc";
                if (redirectUris.Contains(expectedUri))
                {
                    DiagnosticsResult += "? Expected redirect URI is configured\n";
                }
                else
                {
                    DiagnosticsResult += $"? Expected redirect URI '{expectedUri}' is NOT configured\n";
                    DiagnosticsResult += "This is likely the cause of your infinite loop!\n";
                }
            }
            else
            {
                DiagnosticsResult += $"Error: {content}\n";
            }
        }
        catch (Exception ex)
        {
            DiagnosticsResult += $"Exception: {ex.Message}\n";
        }
        
        if (!_disposed)
        {
            StateHasChanged();
        }
    }

    private Task ClearAuthState()
    {
        if (_disposed || !_hasRendered) return Task.CompletedTask;

        DiagnosticsResult = "Clearing authentication state...\n";
        StateHasChanged();

        try
        {
            Navigation.NavigateTo("/debug/clear-auth", forceLoad: true);
        }
        catch (Exception ex)
        {
            DiagnosticsResult += $"Error: {ex.Message}\n";
            if (!_disposed)
            {
                StateHasChanged();
            }
        }

        return Task.CompletedTask;
    }

    private Task TestLogin()
    {
        if (_disposed || !_hasRendered) return Task.CompletedTask;

        DiagnosticsResult = "Starting login test...\n";
        StateHasChanged();

        try
        {
            Navigation.NavigateTo("/login?returnUrl=/debug/auth-diagnostics", forceLoad: true);
        }
        catch (Exception ex)
        {
            DiagnosticsResult += $"Error: {ex.Message}\n";
            if (!_disposed)
            {
                StateHasChanged();
            }
        }

        return Task.CompletedTask;
    }

    private void StartParViaChallenge()
    {
        if (_disposed || !_hasRendered) return;
        var ret = Uri.EscapeDataString("/debug/auth-diagnostics");
        Navigation.NavigateTo($"/auth/login?par=true&returnUrl={ret}", forceLoad: true);
    }

    private async Task ParLoginWithLocalCallback()
    {
        if (_disposed || !_hasRendered) return;

        DiagnosticsResult = "PAR login test (local callback): pushing request...\n";
        StateHasChanged();

        try
        {
            var authCfg = Configuration.GetSection("Authentication");
            var clientId = authCfg.GetValue<string>("ClientId") ?? "mrwho_admin_web";
            var clientSecret = authCfg.GetValue<string>("ClientSecret");
            var scope = authCfg.GetValue<string>("Scope") ?? "openid profile email";
            var redirectUri = Navigation.BaseUri.TrimEnd('/') + "/callback"; // local diagnostics page (no middleware)

            var pkce = CreatePkce();
            await JSRuntime.InvokeVoidAsync("eval", $"sessionStorage.setItem('mrwho.par.pkce_verifier','{pkce.Verifier}')");
            var state = Guid.NewGuid().ToString("n");
            var nonce = Guid.NewGuid().ToString("n");

            using var http = new HttpClient { Timeout = TimeSpan.FromSeconds(10) };
            var parUrl = Combine(Authority, "/connect/par");

            var form = new List<KeyValuePair<string, string>>
            {
                new("client_id", clientId),
                new("redirect_uri", redirectUri),
                new("response_type", "code"),
                new("scope", scope),
                new("state", state),
                new("nonce", nonce),
                new("code_challenge", pkce.Challenge),
                new("code_challenge_method", "S256")
            };
            if (!string.IsNullOrWhiteSpace(clientSecret)) form.Add(new("client_secret", clientSecret));

            var resp = await http.PostAsync(parUrl, new FormUrlEncodedContent(form));
            var body = await resp.Content.ReadAsStringAsync();
            DiagnosticsResult += $"PAR status: {(int)resp.StatusCode} {resp.StatusCode}\n";
            if (!resp.IsSuccessStatusCode) { DiagnosticsResult += body + "\n"; StateHasChanged(); return; }

            using var doc = System.Text.Json.JsonDocument.Parse(body);
            var requestUri = doc.RootElement.GetProperty("request_uri").GetString();
            var authorizeUrl = Combine(Authority, "/connect/authorize") + $"?client_id={Uri.EscapeDataString(clientId)}&request_uri={Uri.EscapeDataString(requestUri!)}&response_mode=jwt";
            Navigation.NavigateTo(authorizeUrl, forceLoad: true);
        }
        catch (Exception ex)
        {
            DiagnosticsResult += $"PAR exception: {ex.Message}\n";
            if (ex.InnerException != null) DiagnosticsResult += $"Inner: {ex.InnerException.Message}\n";
            StateHasChanged();
        }
    }

    // Helpers for PKCE reused by both flows
    private static (string Verifier, string Challenge) CreatePkce()
    {
        var bytes = System.Security.Cryptography.RandomNumberGenerator.GetBytes(32);
        string B64Url(byte[] b) => Convert.ToBase64String(b).TrimEnd('=')
            .Replace('+', '-')
            .Replace('/', '_');
        var verifier = B64Url(bytes);
        var hash = System.Security.Cryptography.SHA256.HashData(System.Text.Encoding.ASCII.GetBytes(verifier));
        var challenge = B64Url(hash);
        return (verifier, challenge);
    }

    private string GetStatusClass(string status)
    {
        return status switch
        {
            "success" => "text-success",
            "error" => "text-danger",
            _ => "text-warning"
        };
    }

    public void Dispose()
    {
        _disposed = true;
    }

    // Helpers ------------------------------------------------------------
    private static string NormalizeBaseUrl(string baseUrl)
    {
        return (baseUrl ?? string.Empty).Trim().TrimEnd('/');
    }

    private static string Combine(string baseUrl, string path)
    {
        if (string.IsNullOrWhiteSpace(baseUrl)) return path;
        if (string.IsNullOrWhiteSpace(path)) return baseUrl;
        var left = baseUrl.TrimEnd('/');
        var right = path.StartsWith("/") ? path : "/" + path;
        return left + right;
    }
}